ADVANCED CALCULATOR MIDTERM PROJECT

Project Overview

This midterm assignment focuses on developing a Python-based calculator application. The project is designed to adhere to software engineering best practices, which include writing well-structured and maintainable code, implementing widely used design patterns, integrating detailed logging mechanisms, and utilizing environment variables for flexible configurations. Additionally, Pandas is leveraged for handling data operations, and a command-line interface (REPL) is provided to facilitate user interaction efficiently.

Prerequisites

Python (Ensure Python is installed and added to the system path)
pip (Required for installing dependencies)
Installation
Follow these steps to set up the calculator application:

Clone the repository:
sh
Copy
Edit
git clone https://github.com/Mahathma-b5/Midterm.git
Navigate to the project directory:
sh
Copy
Edit
cd Mid_Term
Install required dependencies:
sh
Copy
Edit
pip install -r requirements.txt
(This ensures all necessary libraries, including Pandas and pytest, are installed.)
Usage
To start the calculator, run:

sh
Copy
Edit
python main.py
This will launch the REPL (Read-Eval-Print Loop) interface, where users can perform arithmetic operations, manage calculation history, and access additional plugin-based functionalities.

Commands

menu – Displays all available plugins, allowing users to explore functionalities dynamically.
add <operand1> <operand2> – Adds two numbers and returns the result.
subtract <operand1> <operand2> – Subtracts the second number from the first.
multiply <operand1> <operand2> – Multiplies two numbers and returns the result.
divide <operand1> <operand2> – Divides the first number by the second.
history_show – Retrieves and displays all previous calculations.
history_clear – Clears all stored historical calculations.
history_save – Saves the entire calculation history to a CSV file, including a timestamp for tracking.
history_load – Loads previously saved calculations from CSV files.
last_op – Displays details of the most recent operation performed.
exit – Closes the calculator application and terminates the REPL session.

Plugins

The calculator application is designed with a dynamic plugin system, ensuring that new functionalities can be added without modifying the core logic. The menu itself is dynamically generated by detecting available plugins. Any new plugin added to the appropriate directory will be automatically loaded into the menu and made available for execution.

Features

Command-Line Interface (REPL): Provides an interactive and user-friendly interface for executing mathematical operations and managing history.
Plugin-Based Architecture: Supports dynamic expansion of functionalities by allowing the loading of additional plugins.
Calculation History Management with Pandas: Ensures smooth handling, storage, and retrieval of calculation records using Pandas DataFrames.
Comprehensive Logging: Implements detailed logging mechanisms to track application activity, errors, and system messages.
Efficient Error Handling: The application is designed to detect and manage invalid inputs, divide-by-zero errors, and other unexpected conditions gracefully.
Design Patterns Implemented
Facade Pattern – Utilized in history management to provide a simplified interface for interacting with stored calculations.
Command Pattern – Manages execution of different arithmetic commands, promoting modularity and separation of concerns.
Factory Method – Applied in calculation.py to efficiently create different types of calculation objects as needed.
These patterns contribute to code maintainability, scalability, and enhanced organization. Additional details regarding their implementations can be found in the source code.

Logging System

A comprehensive logging system is implemented to record all operations, track errors, and log informational messages for debugging and maintenance.

Different log levels (INFO, WARNING, ERROR, DEBUG, CRITICAL) can be configured dynamically.
Logs help in identifying issues, tracking execution flow, and providing insights into application behavior.

Environment Variables

Environment variables are used to allow dynamic configuration of logging levels, file output paths, and other settings, making the application more adaptable and flexible.

sh
Copy
Edit
LOG_LEVEL=DEBUG   # Options: INFO, WARNING, ERROR, CRITICAL  
LOG_OUTPUT=./logs/app.log  # Specifies where logs should be stored  
HISTORY_PATH=./calculator_history  # Path to store calculation history  
ENVIRONMENT=DEVELOPMENT  # Can be set to DEVELOPMENT or PRODUCTION  
(These settings can be adjusted based on user requirements or deployment needs.)

Testing & Coverage

To validate the functionality of the application, 
run:

sh
Copy
Edit
pytest
To check code coverage and linting compliance, use:

sh
Copy
Edit
pytest --pylint --cov
Tests ensure the calculator operates as expected, handles errors gracefully, and maintains high code quality standards.
Running coverage reports helps in identifying untested parts of the codebase, improving overall reliability.

EAFP & LBYL

LBYL (Look Before You Leap)
This approach checks conditions before executing an operation, preventing potential errors in advance.

Code Example:

python
Copy
Edit
def get_value(dictionary, key):
    if key in dictionary:  # Checking before accessing
        return dictionary[key]
    else:
        print(f"Key '{key}' not found in dictionary")
        return None
Here, the function checks if the key exists in the dictionary before accessing it to prevent an error.

EAFP (Easier to Ask for Forgiveness than Permission)
This approach assumes the operation will succeed and handles exceptions if it fails.

Code Example:

python
Copy
Edit
def get_value(dictionary, key):
    try:
        return dictionary[key]  # Attempting without checking
    except KeyError:
        print(f"Key '{key}' not found in dictionary")
        return None
Here, instead of checking if the key exists first, the function tries accessing it directly and catches the error if it occurs.

Both approaches are commonly used in Python, with EAFP being the more "Pythonic" way, as it relies on exception handling rather than explicit condition checks.
